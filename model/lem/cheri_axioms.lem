open import Pervasives_extra
open import Sail2_values
open import Sail2_prompt_monad
open import Sail2_operators
open import Capabilities

(* ISA characterisation for the abstract CHERI model *)

(* Memory access types
   TODO: Maybe add a read_kind for instruction fetches, so that we can
   distinguish loads from fetches in events and don't need to carry around the
   is_fetch parameter below.  Similarly, a {read,write}_kind for translation
   table accesses would be useful. *)
type acctype = Load | Store | Fetch | PTW (* page table walk *)

type trace_kind 'instr = Instr_Trace of 'instr | Fetch_Trace

type isa_trace 'regval 'instr =
  <| trace : trace 'regval;
     trace_kind : trace_kind 'instr |>

type isa 'cap 'regval 'instr 'e =
  <| instr_sem : 'instr -> monad 'regval unit 'e;
     instr_fetch : monad 'regval 'instr 'e;
     tag_granule : nat;
     PCC : set register_name;
     KCC : set register_name;
     IDC : set register_name;
     caps_of_regval : 'regval -> set 'cap;
     trace_uses_mem_caps : isa_trace 'regval 'instr -> bool;
     instr_invokes_indirect_caps : 'instr -> trace 'regval -> set 'cap;
     instr_invokes_code_caps : 'instr -> trace 'regval -> set 'cap;
     instr_invokes_data_caps : 'instr -> trace 'regval -> set 'cap;
     (* Offsets of code and data capabilities, respectively, loaded via
        points-to-pair indirect sentry capabilities
        (Section C.9.2 of CHERI ISAv8) *)
     indirect_pair_sentry_code_offset : nat;
     indirect_pair_sentry_data_offset : nat;
     trace_raises_ex : isa_trace 'regval 'instr -> bool;
     exception_targets : set 'regval -> set 'cap;
     read_privileged_regs : set register_name;
     write_privileged_regs : set register_name;
     read_exception_regs : set register_name;
     write_exception_regs : set register_name;
     is_translation_event : event 'regval -> bool;
     translate_address : address -> acctype -> trace 'regval -> maybe address |>

(* Helper functions *)

val event_at_idx : forall 'regval 'instr. nat -> isa_trace 'regval 'instr -> maybe (event 'regval)
let event_at_idx i t = index t.trace i

let writes_mem_val_at_idx i t = Maybe.bind (event_at_idx i t) writes_mem_val
let writes_mem_cap_at_idx i t = Maybe.bind (event_at_idx i t) writes_mem_cap
let writes_to_reg_at_idx i t = Maybe.bind (event_at_idx i t) writes_to_reg
let writes_reg_caps_at_idx ISA i t = maybe Set.empty (writes_reg_caps ISA.caps_of_regval) (event_at_idx i t)
let reads_mem_val_at_idx i t = Maybe.bind (event_at_idx i t) reads_mem_val
let reads_mem_cap_at_idx i t = Maybe.bind (event_at_idx i t) reads_mem_cap
let reads_from_reg_at_idx i t = Maybe.bind (event_at_idx i t) reads_from_reg
let reads_reg_caps_at_idx ISA i t = maybe Set.empty (reads_reg_caps ISA.caps_of_regval) (event_at_idx i t)
let translation_event_at_idx ISA i t = match (event_at_idx i t) with
  | Just e -> ISA.is_translation_event e
  | Nothing -> false
end
let read_from_KCC_at_idx ISA i t = {v' | exists r' j. j < i && event_at_idx j t = Just (E_read_reg r' v') && r' IN ISA.KCC}
let exception_targets_at_idx ISA i t = ISA.exception_targets (read_from_KCC_at_idx ISA i t)

val is_fetch_trace : forall 'regval 'instr. isa_trace 'regval 'instr -> bool
let is_fetch_trace t = (t.trace_kind = Fetch_Trace)

val instr_invokes_caps : forall 'cap 'regval 'instr 'e. SetType 'cap => isa 'cap 'regval 'instr 'e -> 'instr -> trace 'regval -> set 'cap
let instr_invokes_caps ISA instr t = ISA.instr_invokes_code_caps instr t union ISA.instr_invokes_data_caps instr t

val trace_invokes_indirect_caps : forall 'cap 'regval 'instr 'e. SetType 'cap => isa 'cap 'regval 'instr 'e -> isa_trace 'regval 'instr -> set 'cap
let trace_invokes_indirect_caps ISA t = match t.trace_kind with
  | Instr_Trace instr -> ISA.instr_invokes_indirect_caps instr t.trace
  | Fetch_Trace -> Set.empty
end

val trace_invokes_code_caps : forall 'cap 'regval 'instr 'e. SetType 'cap => isa 'cap 'regval 'instr 'e -> isa_trace 'regval 'instr -> set 'cap
let trace_invokes_code_caps ISA t = match t.trace_kind with
  | Instr_Trace instr -> ISA.instr_invokes_code_caps instr t.trace
  | Fetch_Trace -> Set.empty
end

val trace_invokes_data_caps : forall 'cap 'regval 'instr 'e. SetType 'cap => isa 'cap 'regval 'instr 'e -> isa_trace 'regval 'instr -> set 'cap
let trace_invokes_data_caps ISA t = match t.trace_kind with
  | Instr_Trace instr -> ISA.instr_invokes_data_caps instr t.trace
  | Fetch_Trace -> Set.empty
end

let ev_writes_pcc_caps ISA = function
  | E_write_reg r v -> if r IN ISA.PCC then ISA.caps_of_regval v else {}
  | _ -> {}
end

let trace_writes_pcc_caps ISA t = List.foldl (union) {} (List.map (ev_writes_pcc_caps ISA) t.trace)

val address_tag_aligned : forall 'cap 'regval 'instr 'e.
  isa 'cap 'regval 'instr 'e -> address -> bool
let address_tag_aligned ISA addr = (addr mod ISA.tag_granule = 0)

val cap_reg_written_before_idx : forall 'cap 'regval 'instr 'e. Capability 'cap, Eq 'cap, SetType 'cap =>
  isa 'cap 'regval 'instr 'e -> nat -> register_name -> isa_trace 'regval 'instr -> bool
let cap_reg_written_before_idx ISA i r t = (exists j. j < i && writes_to_reg_at_idx j t = Just r && not (writes_reg_caps_at_idx ISA j t = {}))

val system_access_permitted_before_idx : forall 'cap 'regval 'instr 'e. Capability 'cap, SetType 'cap, Eq 'cap =>
  isa 'cap 'regval 'instr 'e -> nat -> isa_trace 'regval 'instr -> bool
let system_access_permitted_before_idx ISA i t =
  (exists j r c.
     j < i &&
     reads_from_reg_at_idx j t = Just r &&
     not (cap_reg_written_before_idx ISA j r t) &&
     c IN (reads_reg_caps_at_idx ISA j t) &&
     r IN ISA.PCC && r NIN ISA.read_privileged_regs &&
     is_tagged c && not (is_sealed c) &&
     permits_system_access c)

val permits_cap_load : forall 'cap. Capability 'cap => 'cap -> address -> nat -> bool
let permits_cap_load c vaddr sz =
  (is_tagged c && not (is_sealed c) &&
   Set.fromList (address_range vaddr sz) subset (get_mem_region c) &&
   permits_load_cap c)

(* Characterisation of available capabilities at given point in a trace *)

val accessed_mem_caps_at_idx : forall 'cap 'regval 'instr 'e. Capability 'cap, Eq 'cap, SetType 'cap =>
  isa 'cap 'regval 'instr 'e -> nat -> isa_trace 'regval 'instr -> set (address * 'cap)
let rec accessed_mem_caps_at_idx ISA i t = match i with
  | 0 -> Set.empty
  | i+1 ->
     let cap_loads_of e =
       (* Collect capabilities read from memory *)
       match reads_mem_cap e with
         | Just (addr, _, c) ->
            (* ... but ignore memory loads that happen as part of address translation *)
            if ISA.is_translation_event e then Set.empty else Set.singleton (addr, c)
         | Nothing -> Set.empty
       end
     in
     let new_cap_loads = maybe Set.empty cap_loads_of (event_at_idx i t) in
     (accessed_mem_caps_at_idx ISA i t) union new_cap_loads
end

val available_mem_caps : forall 'cap 'regval 'instr 'e. Capability 'cap, Eq 'cap, SetType 'cap =>
  isa 'cap 'regval 'instr 'e -> nat -> isa_trace 'regval 'instr -> set 'cap
let available_mem_caps ISA i t = {c | exists addr. (addr, c) IN accessed_mem_caps_at_idx ISA i t}

val available_reg_caps : forall 'cap 'regval 'instr 'e. Capability 'cap, Eq 'cap, SetType 'cap =>
  isa 'cap 'regval 'instr 'e -> nat -> isa_trace 'regval 'instr -> set 'cap
let rec available_reg_caps ISA i t = match i with
  | 0 -> Set.empty
  | i+1 ->
     let caps_of e =
       (match reads_from_reg e with
          | Just r ->
	     (* Collect capabilities read from accessible registers (if PCC or IDC have been written to,
                we don't allow the use of capabilities read back from them, as those might come from a
                non-monotonic capability invocation) *)
             if (((r IN ISA.PCC || r IN ISA.IDC) --> not (cap_reg_written_before_idx ISA i r t)) &&
                 (system_access_permitted_before_idx ISA i t || not (r IN ISA.read_privileged_regs)))
             then reads_reg_caps ISA.caps_of_regval e
             else Set.empty
          | Nothing -> Set.empty
        end)
     in
     let new_caps = maybe Set.empty caps_of (event_at_idx i t) in
     (available_reg_caps ISA i t) union new_caps
end

declare termination_argument accessed_mem_caps_at_idx = automatic
declare termination_argument available_reg_caps = automatic

(* Collect capabilities available from register reads or, possibly, memory
   loads (we disallow use of capabilities loaded from memory in case of
   instructions that perform indirect sentry invocations *)
val available_caps : forall 'cap 'regval 'instr 'e. Capability 'cap, Eq 'cap, SetType 'cap =>
  isa 'cap 'regval 'instr 'e -> nat -> isa_trace 'regval 'instr -> set 'cap
let available_caps ISA i t =
  (available_reg_caps ISA i t) union (if ISA.trace_uses_mem_caps t && trace_invokes_indirect_caps ISA t = {} then available_mem_caps ISA i t else Set.empty)

(* Properties we require for CHERI ISAs *)

val read_reg_axiom : forall 'cap 'regval 'instr 'e. Capability 'cap, SetType 'cap, Eq 'cap, Eq 'regval =>
  isa 'cap 'regval 'instr 'e -> nat -> isa_trace 'regval 'instr -> bool
let read_reg_axiom ISA n t =
  (forall i r v.
     (i < n && event_at_idx i t = Just (E_read_reg r v) && r IN ISA.read_privileged_regs)
     -->
     (* Check system access permission before reading privileged registers
        (allowing read_exception_regs in the exception case) *)
     (system_access_permitted_before_idx ISA i t ||
      (ISA.trace_raises_ex t && r IN ISA.read_exception_regs)))

val write_reg_axiom : forall 'cap 'regval 'instr 'e. Capability 'cap, SetType 'cap, Eq 'cap, Eq 'regval =>
  isa 'cap 'regval 'instr 'e -> nat -> isa_trace 'regval 'instr -> bool
let write_reg_axiom ISA n t =
  (forall i r v.
     (i < n && event_at_idx i t = Just (E_write_reg r v) && r IN ISA.write_privileged_regs)
     -->
     (system_access_permitted_before_idx ISA i t ||
      (ISA.trace_raises_ex t && r IN ISA.write_exception_regs)))

val store_cap_mem_axiom : forall 'cap 'regval 'instr 'e. Capability 'cap, SetType 'cap, Eq 'cap =>
  isa 'cap 'regval 'instr 'e -> set 'cap -> nat -> isa_trace 'regval 'instr -> bool
let store_cap_mem_axiom ISA initial_caps n t =
  (forall i c addr sz.
     (i < n && writes_mem_cap_at_idx i t = Just (addr, sz, c))
     -->
     (* Only store monotonically derivable capabilities to memory *)
     (cap_derivable (initial_caps union available_caps ISA i t) c))

let is_invoked_pair_code_cap_at_idx ISA c t i =
  (exists cc cd.
     cc IN available_caps ISA i t &&
     cd IN available_caps ISA i t &&
     invokable cc cd &&
     leq_cap c (unseal cc) && c IN trace_invokes_code_caps ISA t)

let is_invoked_pair_data_cap_at_idx ISA c t i =
  (exists cc cd.
     cc IN available_caps ISA i t &&
     cd IN available_caps ISA i t &&
     invokable cc cd &&
     leq_cap c (unseal cd) && c IN trace_invokes_data_caps ISA t)

let is_invoked_direct_sentry_at_idx ISA c t i =
  (exists cs.
     c IN trace_invokes_code_caps ISA t &&
     cs IN available_caps ISA i t &&
     is_tagged cs && is_sealed cs && is_sentry cs &&
     leq_cap c (unseal cs))

val is_invoked_indirect_sentry_at_idx : forall 'cap 'regval 'instr 'e. Capability 'cap, SetType 'cap, Eq 'cap =>
  isa 'cap 'regval 'instr 'e -> 'cap -> indirect_sentry_type -> isa_trace 'regval 'instr -> nat -> bool
let is_invoked_indirect_sentry_at_idx ISA c sentry_type t i =
  (exists c'.
     c' IN available_caps ISA i t &&
     is_tagged c' && is_sealed c' &&
     get_indirect_sentry_type c' = Just sentry_type &&
     leq_cap c (unseal c') &&
     c IN trace_invokes_indirect_caps ISA t)

val is_indirectly_invoked_cap_at_idx : forall 'cap 'regval 'instr 'e. Capability 'cap, SetType 'cap, Eq 'cap =>
  isa 'cap 'regval 'instr 'e -> 'cap -> indirect_sentry_type -> maybe nat -> 'cap -> isa_trace 'regval 'instr -> nat -> bool
let is_indirectly_invoked_cap_at_idx ISA (sentry : 'cap) sentry_type required_offset (c : 'cap) t i =
  (exists paddr.
     is_invoked_indirect_sentry_at_idx ISA sentry sentry_type t i &&
     (match required_offset with
      | Just offset ->
         let vaddr = get_cursor sentry + offset in
         ISA.translate_address vaddr Load (take i t.trace) = Just paddr
      | Nothing -> true
      end) &&
     ISA.trace_uses_mem_caps t &&
     (paddr, c) IN accessed_mem_caps_at_idx ISA i t)

let is_indirectly_invoked_single_code_cap_at_idx ISA c t i =
  (exists cs c'.
     is_indirectly_invoked_cap_at_idx ISA cs Points_to_PCC Nothing c' t i &&
     (leq_cap c c' || (leq_cap c (unseal c') && is_sealed c' && is_sentry c')) &&
     c IN trace_invokes_code_caps ISA t)

let is_indirectly_invoked_single_data_cap_at_idx ISA c t i =
  (is_invoked_indirect_sentry_at_idx ISA c Points_to_PCC t i &&
   c IN trace_invokes_data_caps ISA t)

let is_indirectly_invoked_pair_code_cap_at_idx ISA c t i =
  (exists c' cs.
     is_indirectly_invoked_cap_at_idx ISA cs Points_to_Pair (Just ISA.indirect_pair_sentry_code_offset) c' t i &&
     (leq_cap c c' || (leq_cap c (unseal c') && is_sealed c' && is_sentry c')) &&
     c IN trace_invokes_code_caps ISA t)

let is_indirectly_invoked_pair_data_cap_at_idx ISA c t i =
  (exists c' cs.
     is_indirectly_invoked_cap_at_idx ISA cs Points_to_Pair (Just ISA.indirect_pair_sentry_data_offset) c' t i &&
     leq_cap c c' &&
     c IN trace_invokes_data_caps ISA t)

let is_invoked_code_cap_at_idx ISA c t i =
  is_invoked_pair_code_cap_at_idx ISA c t i ||
  is_invoked_direct_sentry_at_idx ISA c t i ||
  is_indirectly_invoked_single_code_cap_at_idx ISA c t i ||
  is_indirectly_invoked_pair_code_cap_at_idx ISA c t i

let is_invoked_data_cap_at_idx ISA c t i =
  is_invoked_pair_data_cap_at_idx ISA c t i ||
  is_indirectly_invoked_single_data_cap_at_idx ISA c t i ||
  is_indirectly_invoked_pair_data_cap_at_idx ISA c t i

val store_cap_reg_axiom : forall 'cap 'regval 'instr 'e. Capability 'cap, SetType 'cap, SetType 'regval, Eq 'cap, Eq 'regval =>
  isa 'cap 'regval 'instr 'e -> set 'cap -> nat -> isa_trace 'regval 'instr -> bool
let store_cap_reg_axiom ISA initial_caps n t =
  (forall i c r.
     (i < n && writes_to_reg_at_idx i t = Just r && c IN (writes_reg_caps_at_idx ISA i t))
     -->
     (* Only store monotonically derivable capabilities to registers *)
     (cap_derivable (initial_caps union available_caps ISA i t) c ||
     (* ... or perform one of the following non-monotonic register writes: *)
     (* Exception *)
     (ISA.trace_raises_ex t && c IN exception_targets_at_idx ISA i t && r IN ISA.PCC) ||
     (* Capability invocation *)
     (is_invoked_code_cap_at_idx ISA c t i && r IN ISA.PCC) ||
     (is_invoked_data_cap_at_idx ISA c t i && r IN ISA.IDC)))

(* If a not-normally-derivable capability is written to IDC, then an invoked code capability must be written to PCC *)
val idc_write_axiom : forall 'cap 'regval 'instr 'e. Capability 'cap, SetType 'cap, SetType 'regval, Eq 'cap, Eq 'regval =>
  isa 'cap 'regval 'instr 'e -> set 'cap -> isa_trace 'regval 'instr -> bool
let idc_write_axiom ISA initial_caps t =
  (forall i c idc.
     (writes_to_reg_at_idx i t = Just idc && idc IN ISA.IDC && c IN (writes_reg_caps_at_idx ISA i t))
     -->
     (cap_derivable (initial_caps union available_caps ISA i t) c ||
      (exists cc. cc IN trace_invokes_code_caps ISA t && trace_writes_pcc_caps ISA t = {cc})))

val load_mem_axiom : forall 'cap 'regval 'instr 'e. Capability 'cap, SetType 'cap, Eq 'cap =>
  isa 'cap 'regval 'instr 'e -> set 'cap -> nat -> isa_trace 'regval 'instr -> bool
let load_mem_axiom ISA initial_caps n t =
  (forall i paddr sz v tag.
     (i < n && reads_mem_val_at_idx i t = Just (paddr, sz, v, tag) &&
      not (translation_event_at_idx ISA i t))
     -->
     (* Only perform memory loads (outside address translation) with a suitable authorising capability *)
     (exists c' vaddr.
        cap_derivable (initial_caps union available_caps ISA i t) c' && is_tagged c' &&
        (is_sealed c' --> is_indirect_sentry c' && unseal c' IN trace_invokes_indirect_caps ISA t) &&
        ISA.translate_address vaddr (if is_fetch_trace t then Fetch else Load) (take i t.trace) = Just paddr &&
        Set.fromList (address_range vaddr sz) subset (get_mem_region c') &&
        (if is_fetch_trace t then permits_execute c' else permits_load c') &&
        (is_fetch_trace t --> tag = B0) &&
        (tag <> B0 && ISA.trace_uses_mem_caps t --> permits_load_cap c' && sz = ISA.tag_granule && address_tag_aligned ISA paddr)))

val mem_val_is_cap : forall 'cap 'regval 'instr 'e. Capability 'cap, SetType 'cap, Eq 'cap =>
  isa 'cap 'regval 'instr 'e -> list memory_byte -> bitU -> bool
let mem_val_is_cap _ v t = (exists c. cap_of_mem_bytes v t = Just (c : 'cap))

val mem_val_is_local_cap : forall 'cap 'regval 'instr 'e. Capability 'cap, SetType 'cap, Eq 'cap =>
  isa 'cap 'regval 'instr 'e -> list memory_byte -> bitU -> bool
let mem_val_is_local_cap _ v t = (exists c. cap_of_mem_bytes v t = Just (c : 'cap) && not (is_global c))

val store_tag_axiom : forall 'cap 'regval 'instr 'e. Capability 'cap, SetType 'cap, Eq 'cap =>
  isa 'cap 'regval 'instr 'e -> nat -> isa_trace 'regval 'instr -> bool
let store_tag_axiom ISA n t =
  (forall i paddr sz v tag.
     (i < n && writes_mem_val_at_idx i t = Just (paddr, sz, v, tag))
     -->
     (* Only store tagged memory values if they are capability-sized and aligned *)
     (List.length v = sz &&
      (tag = B0 || tag = B1) &&
      (tag = B1 --> address_tag_aligned ISA paddr && sz = ISA.tag_granule)))

val store_mem_axiom : forall 'cap 'regval 'instr 'e. Capability 'cap, SetType 'cap, Eq 'cap =>
  isa 'cap 'regval 'instr 'e -> set 'cap -> nat -> isa_trace 'regval 'instr -> bool
let store_mem_axiom ISA initial_caps n t =
  (forall i paddr sz v tag.
     (i < n && writes_mem_val_at_idx i t = Just (paddr, sz, v, tag) &&
      not (translation_event_at_idx ISA i t))
     -->
     (* Only perform memory stores (outside address translation) with a suitable authorising capability *)
     (exists c' vaddr.
        cap_derivable (initial_caps union available_caps ISA i t) c' && is_tagged c' && not (is_sealed c') &&
        ISA.translate_address vaddr Store (take i t.trace) = Just paddr &&
        Set.fromList (address_range vaddr sz) subset (get_mem_region c') &&
        permits_store c' &&
        ((mem_val_is_cap ISA v tag && tag = B1) --> permits_store_cap c') &&
        (mem_val_is_local_cap ISA v tag && tag = B1 --> permits_store_local_cap c')))

val cheri_axioms : forall 'cap 'regval 'instr 'e. Capability 'cap, SetType 'cap, SetType 'regval, Eq 'cap, Eq 'regval =>
  isa 'cap 'regval 'instr 'e -> set 'cap -> nat -> isa_trace 'regval 'instr -> bool
let cheri_axioms ISA initial_caps n t =
  store_cap_mem_axiom ISA initial_caps n t &&
  store_cap_reg_axiom ISA initial_caps n t &&
  read_reg_axiom ISA n t &&
  write_reg_axiom ISA n t &&
  load_mem_axiom ISA initial_caps n t &&
  store_tag_axiom ISA n t &&
  store_mem_axiom ISA initial_caps n t &&
  idc_write_axiom ISA initial_caps t
