chapter \<open>Generated by Lem from \<open>capabilities.lem\<close>.\<close>

theory "Capabilities" 

imports
  Main
  "LEM.Lem_pervasives_extra"
  "Sail.Sail2_values"
  "Sail.Sail2_prompt_monad"

begin 

\<comment> \<open>\<open>open import Pervasives_extra\<close>\<close>
\<comment> \<open>\<open>open import Sail2_values\<close>\<close>
\<comment> \<open>\<open>open import Sail2_prompt_monad\<close>\<close>

\<comment> \<open>\<open> Abstraction of capabilities \<close>\<close>

type_synonym perms =" bool list "

type_synonym address0 =" nat "
type_synonym otype =" nat "

record 'c Capability_class=

  is_tagged_method ::" 'c \<Rightarrow> bool " 

  is_sealed_method ::" 'c \<Rightarrow> bool " 

  is_sentry_method ::" 'c \<Rightarrow> bool " 

  is_indirect_sentry_method ::" 'c \<Rightarrow> bool " 

  get_base_method ::" 'c \<Rightarrow> address0 " 

  get_top_method ::" 'c \<Rightarrow> address0 " 

  get_obj_type_method ::" 'c \<Rightarrow> otype " 

  get_perms_method ::" 'c \<Rightarrow> perms " 

  get_cursor_method ::" 'c \<Rightarrow> address0 " 

  is_global_method ::" 'c \<Rightarrow> bool " 

  seal_method ::" 'c \<Rightarrow> otype \<Rightarrow> 'c " 

  unseal_method ::" 'c \<Rightarrow> 'c " 

  clear_global_method ::" 'c \<Rightarrow> 'c " 

  cap_of_mem_bytes_method ::" memory_byte list \<Rightarrow> bitU \<Rightarrow>  'c option " 

  permits_execute_method ::" 'c \<Rightarrow> bool " 

  permits_ccall_method ::" 'c \<Rightarrow> bool " 

  permits_load_method ::" 'c \<Rightarrow> bool " 

  permits_load_cap_method ::" 'c \<Rightarrow> bool " 

  permits_seal_method ::" 'c \<Rightarrow> bool " 

  permits_store_method ::" 'c \<Rightarrow> bool " 

  permits_store_cap_method ::" 'c \<Rightarrow> bool " 

  permits_store_local_cap_method ::" 'c \<Rightarrow> bool " 

  permits_system_access_method ::" 'c \<Rightarrow> bool " 

  permits_unseal_method ::" 'c \<Rightarrow> bool "



\<comment> \<open>\<open> Capability ordering with respect to their bounds and permissions \<close>\<close>

\<comment> \<open>\<open>val address_range : address -> address -> list address\<close>\<close>
definition address_range  :: \<open> nat \<Rightarrow> nat \<Rightarrow>(nat)list \<close>  where 
     \<open> address_range start len = ( genlist ((\<lambda> n .  start + n)) len )\<close> 
  for  start  :: " nat " 
  and  len  :: " nat "


\<comment> \<open>\<open>val get_mem_region : forall 'cap. Capability 'cap => 'cap -> set address\<close>\<close>
definition get_mem_region  :: \<open> 'cap Capability_class \<Rightarrow> 'cap \<Rightarrow>(nat)set \<close>  where 
     \<open> get_mem_region dict_Capabilities_Capability_cap c = (
  if (get_top_method   dict_Capabilities_Capability_cap) c <(get_base_method   dict_Capabilities_Capability_cap) c then {} else
  (let len = ((get_top_method   dict_Capabilities_Capability_cap) c -(get_base_method   dict_Capabilities_Capability_cap) c) in
  List.set (address_range (
  (get_base_method   dict_Capabilities_Capability_cap) c) len)))\<close> 
  for  dict_Capabilities_Capability_cap  :: " 'cap Capability_class " 
  and  c  :: " 'cap "


\<comment> \<open>\<open>val leq_bools : list bool -> list bool -> bool\<close>\<close>
fun  leq_bools  :: \<open>(bool)list \<Rightarrow>(bool)list \<Rightarrow> bool \<close>  where 
     \<open> leq_bools ([]) ([]) = ( True )\<close>
|\<open> leq_bools (_ # _) ([]) = ( False )\<close>
|\<open> leq_bools ([]) (_ # _) = ( False )\<close>
|\<open> leq_bools (b1 # l1) (b2 # l2) = ( (b1 \<longrightarrow> b2) \<and> leq_bools l1 l2 )\<close> 
  for  l1  :: "(bool)list " 
  and  b1  :: " bool " 
  and  l2  :: "(bool)list " 
  and  b2  :: " bool "


\<comment> \<open>\<open>val leq_perms : forall 'cap. Capability 'cap => 'cap -> 'cap -> bool\<close>\<close>
definition leq_perms  :: \<open> 'cap Capability_class \<Rightarrow> 'cap \<Rightarrow> 'cap \<Rightarrow> bool \<close>  where 
     \<open> leq_perms dict_Capabilities_Capability_cap c1 c2 = (
  (leq_bools ((get_perms_method   dict_Capabilities_Capability_cap) c1) ((get_perms_method   dict_Capabilities_Capability_cap) c2) \<and>
   (((permits_execute_method   dict_Capabilities_Capability_cap) c1 \<longrightarrow> 
  (permits_execute_method   dict_Capabilities_Capability_cap) c2) \<and>
   (((permits_ccall_method   dict_Capabilities_Capability_cap) c1 \<longrightarrow> 
  (permits_ccall_method   dict_Capabilities_Capability_cap) c2) \<and>
   (((permits_load_method   dict_Capabilities_Capability_cap) c1 \<longrightarrow> 
  (permits_load_method   dict_Capabilities_Capability_cap) c2) \<and>
   (((permits_load_cap_method   dict_Capabilities_Capability_cap) c1 \<longrightarrow> 
  (permits_load_cap_method   dict_Capabilities_Capability_cap) c2) \<and>
   (((permits_seal_method   dict_Capabilities_Capability_cap) c1 \<longrightarrow> 
  (permits_seal_method   dict_Capabilities_Capability_cap) c2) \<and>
   (((permits_store_method   dict_Capabilities_Capability_cap) c1 \<longrightarrow> 
  (permits_store_method   dict_Capabilities_Capability_cap) c2) \<and>
   (((permits_store_cap_method   dict_Capabilities_Capability_cap) c1 \<longrightarrow> 
  (permits_store_cap_method   dict_Capabilities_Capability_cap) c2) \<and>
   (((permits_store_local_cap_method   dict_Capabilities_Capability_cap) c1 \<longrightarrow> 
  (permits_store_local_cap_method   dict_Capabilities_Capability_cap) c2) \<and>
   (((permits_system_access_method   dict_Capabilities_Capability_cap) c1 \<longrightarrow> 
  (permits_system_access_method   dict_Capabilities_Capability_cap) c2) \<and>
   ((permits_unseal_method   dict_Capabilities_Capability_cap) c1 \<longrightarrow> 
  (permits_unseal_method   dict_Capabilities_Capability_cap) c2))))))))))))\<close> 
  for  dict_Capabilities_Capability_cap  :: " 'cap Capability_class " 
  and  c1  :: " 'cap " 
  and  c2  :: " 'cap "


\<comment> \<open>\<open>val leq_bounds : forall 'cap. Capability 'cap => 'cap -> 'cap -> bool\<close>\<close>
definition leq_bounds  :: \<open> 'cap Capability_class \<Rightarrow> 'cap \<Rightarrow> 'cap \<Rightarrow> bool \<close>  where 
     \<open> leq_bounds dict_Capabilities_Capability_cap c1 c2 = (
  (((get_base_method   dict_Capabilities_Capability_cap) c1 =(get_base_method   dict_Capabilities_Capability_cap) c2) \<and> ((get_top_method   dict_Capabilities_Capability_cap) c1 =(get_top_method   dict_Capabilities_Capability_cap) c2)) \<or>
  (((get_base_method   dict_Capabilities_Capability_cap) c1 \<ge> (get_base_method   dict_Capabilities_Capability_cap) c2) \<and>
   (((get_top_method   dict_Capabilities_Capability_cap) c1 \<le> (get_top_method   dict_Capabilities_Capability_cap) c2) \<and>
   ((get_base_method   dict_Capabilities_Capability_cap) c1 \<le> (get_top_method   dict_Capabilities_Capability_cap) c1))))\<close> 
  for  dict_Capabilities_Capability_cap  :: " 'cap Capability_class " 
  and  c1  :: " 'cap " 
  and  c2  :: " 'cap "


\<comment> \<open>\<open>val leq_cap : forall 'cap. Capability 'cap, Eq 'cap => 'cap -> 'cap -> bool\<close>\<close>
definition leq_cap  :: \<open> 'cap Capability_class \<Rightarrow> 'cap \<Rightarrow> 'cap \<Rightarrow> bool \<close>  where 
     \<open> leq_cap dict_Capabilities_Capability_cap c1 c2 = (
  (c1 = c2) \<or>
  ((\<not> ((is_tagged_method   dict_Capabilities_Capability_cap) c1)) \<or>
    (((is_tagged_method   dict_Capabilities_Capability_cap) c2) \<and>
     ((\<not> ((is_sealed_method   dict_Capabilities_Capability_cap) c1) \<and> \<not> ((is_sealed_method   dict_Capabilities_Capability_cap) c2)) \<and>
     ((leq_bounds dict_Capabilities_Capability_cap c1 c2) \<and>
     (((is_global_method   dict_Capabilities_Capability_cap) c1 \<longrightarrow> 
  (is_global_method   dict_Capabilities_Capability_cap) c2) \<and>
     (leq_perms dict_Capabilities_Capability_cap c1 c2)))))))\<close> 
  for  dict_Capabilities_Capability_cap  :: " 'cap Capability_class " 
  and  c1  :: " 'cap " 
  and  c2  :: " 'cap "


\<comment> \<open>\<open>val invokable : forall 'cap. Capability 'cap => 'cap -> 'cap -> bool\<close>\<close>
definition invokable  :: \<open> 'cap Capability_class \<Rightarrow> 'cap \<Rightarrow> 'cap \<Rightarrow> bool \<close>  where 
     \<open> invokable dict_Capabilities_Capability_cap cc cd1 = (
  (is_tagged_method   dict_Capabilities_Capability_cap) cc \<and> ((is_tagged_method   dict_Capabilities_Capability_cap) cd1 \<and>
  ((is_sealed_method   dict_Capabilities_Capability_cap) cc \<and> ((is_sealed_method   dict_Capabilities_Capability_cap) cd1 \<and>
  (\<not> ((is_sentry_method   dict_Capabilities_Capability_cap) cc) \<and> (\<not> (
  (is_sentry_method   dict_Capabilities_Capability_cap) cd1) \<and>
  ((permits_ccall_method   dict_Capabilities_Capability_cap) cc \<and> ((permits_ccall_method   dict_Capabilities_Capability_cap) cd1 \<and>
  (((get_obj_type_method   dict_Capabilities_Capability_cap) cc =(get_obj_type_method   dict_Capabilities_Capability_cap) cd1) \<and>
  ((permits_execute_method   dict_Capabilities_Capability_cap) cc \<and> \<not> ((permits_execute_method   dict_Capabilities_Capability_cap) cd1)))))))))))\<close> 
  for  dict_Capabilities_Capability_cap  :: " 'cap Capability_class " 
  and  cc  :: " 'cap " 
  and  cd1  :: " 'cap "


\<comment> \<open>\<open>val clear_global_unless : forall 'cap. Capability 'cap => bool -> 'cap -> 'cap\<close>\<close>
definition clear_global_unless  :: \<open> 'cap Capability_class \<Rightarrow> bool \<Rightarrow> 'cap \<Rightarrow> 'cap \<close>  where 
     \<open> clear_global_unless dict_Capabilities_Capability_cap g c = ( if g then c else 
  (clear_global_method   dict_Capabilities_Capability_cap) c )\<close> 
  for  dict_Capabilities_Capability_cap  :: " 'cap Capability_class " 
  and  g  :: " bool " 
  and  c  :: " 'cap "


\<comment> \<open>\<open> Derivation of capabilities, bounded by derivation depth to guarantee termination \<close>\<close>
\<comment> \<open>\<open>val cap_derivable_bounded : forall 'cap. Capability 'cap, SetType 'cap, Eq 'cap => nat -> set 'cap -> 'cap -> bool\<close>\<close>
fun  cap_derivable_bounded  :: \<open> 'cap Capability_class \<Rightarrow> nat \<Rightarrow> 'cap set \<Rightarrow> 'cap \<Rightarrow> bool \<close>  where 
     \<open> cap_derivable_bounded dict_Capabilities_Capability_cap 0 C c = ( (c \<in> C))\<close> 
  for  dict_Capabilities_Capability_cap  :: " 'cap Capability_class " 
  and  C  :: " 'cap set " 
  and  c  :: " 'cap "
|\<open> cap_derivable_bounded dict_Capabilities_Capability_cap ((Suc n)) C c = (
     ((\<exists> c'.  cap_derivable_bounded 
  dict_Capabilities_Capability_cap n C c' \<and> leq_cap 
  dict_Capabilities_Capability_cap c c')) \<or>
     (((\<exists> c'. \<exists> otype.  cap_derivable_bounded 
  dict_Capabilities_Capability_cap n C c' \<and> ((is_tagged_method   dict_Capabilities_Capability_cap) c' \<and> (\<not> ((is_sealed_method   dict_Capabilities_Capability_cap) c') \<and> (((seal_method   dict_Capabilities_Capability_cap) c' otype = c) \<and> (
  (is_sentry_method   dict_Capabilities_Capability_cap) c \<or> (is_indirect_sentry_method   dict_Capabilities_Capability_cap) c)))))) \<or>
     ((\<exists> c'. \<exists> c''. 
        cap_derivable_bounded 
  dict_Capabilities_Capability_cap n C c' \<and>
        (cap_derivable_bounded 
  dict_Capabilities_Capability_cap n C c'' \<and>
        ((is_tagged_method   dict_Capabilities_Capability_cap) c' \<and> ((is_tagged_method   dict_Capabilities_Capability_cap) c'' \<and> (\<not> (
  (is_sealed_method   dict_Capabilities_Capability_cap) c'') \<and>
        (((get_cursor_method   dict_Capabilities_Capability_cap) c'' \<in> get_mem_region 
  dict_Capabilities_Capability_cap c'') \<and>
        (((is_sealed_method   dict_Capabilities_Capability_cap) c' \<and> ((permits_unseal_method   dict_Capabilities_Capability_cap) c'' \<and> (((get_obj_type_method   dict_Capabilities_Capability_cap) c' =(get_cursor_method   dict_Capabilities_Capability_cap) c'') \<and> (clear_global_unless 
  dict_Capabilities_Capability_cap ((is_global_method   dict_Capabilities_Capability_cap) c'') ((unseal_method   dict_Capabilities_Capability_cap) c') = c)))) \<or>
         (\<not> ((is_sealed_method   dict_Capabilities_Capability_cap) c') \<and> ((permits_seal_method   dict_Capabilities_Capability_cap) c'' \<and> ((seal_method   dict_Capabilities_Capability_cap) c' ((get_cursor_method   dict_Capabilities_Capability_cap) c'') = c)))))))))))))\<close> 
  for  dict_Capabilities_Capability_cap  :: " 'cap Capability_class " 
  and  n  :: " nat " 
  and  C  :: " 'cap set " 
  and  c  :: " 'cap "


\<comment> \<open>\<open> TODO: Prove an upper bound for the derivation depth.  For a finite set of n
   capabilities, it seems a derivation depth of n+1 should be enough: If all
   but one capabilities in C are sealed, up to n-1 unsealing operations and
   possibly a restriction and a sealing operation might be necessary to derive
   the desired capability. \<close>\<close>
definition cap_derivable  :: \<open> 'a Capability_class \<Rightarrow> 'a set \<Rightarrow> 'a \<Rightarrow> bool \<close>  where 
     \<open> cap_derivable dict_Capabilities_Capability_a C c = ( ((\<exists> n.  cap_derivable_bounded 
  dict_Capabilities_Capability_a n C c)))\<close> 
  for  dict_Capabilities_Capability_a  :: " 'a Capability_class " 
  and  C  :: " 'a set " 
  and  c  :: " 'a "


\<comment> \<open>\<open>val reads_from_reg : forall 'regval. event 'regval -> maybe register_name\<close>\<close>
fun reads_from_reg  :: \<open> 'regval event \<Rightarrow>(string)option \<close>  where 
     \<open> reads_from_reg (E_read_reg r _) = ( Some r )\<close> 
  for  r  :: " string "
|\<open> reads_from_reg _ = ( None )\<close>


\<comment> \<open>\<open>val reads_reg_caps : forall 'regval 'cap. Capability 'cap, SetType 'cap =>
  ('regval -> set 'cap) -> event 'regval -> set 'cap\<close>\<close>
fun reads_reg_caps  :: \<open> 'cap Capability_class \<Rightarrow>('regval \<Rightarrow> 'cap set)\<Rightarrow> 'regval event \<Rightarrow> 'cap set \<close>  where 
     \<open> reads_reg_caps dict_Capabilities_Capability_cap caps_of_regval1 (E_read_reg _ v) = ( set_filter 
  (is_tagged_method   dict_Capabilities_Capability_cap) (caps_of_regval1 v))\<close> 
  for  dict_Capabilities_Capability_cap  :: " 'cap Capability_class " 
  and  caps_of_regval1  :: " 'regval \<Rightarrow> 'cap set " 
  and  v  :: " 'regval "
|\<open> reads_reg_caps dict_Capabilities_Capability_cap caps_of_regval1 _ = ( {} )\<close> 
  for  dict_Capabilities_Capability_cap  :: " 'cap Capability_class " 
  and  caps_of_regval1  :: " 'regval \<Rightarrow> 'cap set "


\<comment> \<open>\<open>val writes_to_reg : forall 'regval. event 'regval -> maybe register_name\<close>\<close>
fun writes_to_reg  :: \<open> 'regval event \<Rightarrow>(string)option \<close>  where 
     \<open> writes_to_reg (E_write_reg r _) = ( Some r )\<close> 
  for  r  :: " string "
|\<open> writes_to_reg _ = ( None )\<close>


\<comment> \<open>\<open>val writes_reg_caps : forall 'regval 'cap. Capability 'cap, SetType 'cap =>
  ('regval -> set 'cap) -> event 'regval -> set 'cap\<close>\<close>
fun writes_reg_caps  :: \<open> 'cap Capability_class \<Rightarrow>('regval \<Rightarrow> 'cap set)\<Rightarrow> 'regval event \<Rightarrow> 'cap set \<close>  where 
     \<open> writes_reg_caps dict_Capabilities_Capability_cap caps_of_regval1 (E_write_reg _ v) = ( set_filter 
  (is_tagged_method   dict_Capabilities_Capability_cap) (caps_of_regval1 v))\<close> 
  for  dict_Capabilities_Capability_cap  :: " 'cap Capability_class " 
  and  caps_of_regval1  :: " 'regval \<Rightarrow> 'cap set " 
  and  v  :: " 'regval "
|\<open> writes_reg_caps dict_Capabilities_Capability_cap caps_of_regval1 _ = ( {} )\<close> 
  for  dict_Capabilities_Capability_cap  :: " 'cap Capability_class " 
  and  caps_of_regval1  :: " 'regval \<Rightarrow> 'cap set "


\<comment> \<open>\<open>val reads_mem_val : forall 'regval. event 'regval -> maybe (address * nat * list memory_byte * bitU)\<close>\<close>
fun reads_mem_val  :: \<open> 'regval event \<Rightarrow>(nat*nat*(memory_byte)list*bitU)option \<close>  where 
     \<open> reads_mem_val (E_read_memt _ addr sz (v, t)) = ( Some (addr, sz, v, t))\<close> 
  for  addr  :: " nat " 
  and  sz  :: " nat " 
  and  t  :: " bitU " 
  and  v  :: "(memory_byte)list "
|\<open> reads_mem_val (E_read_mem _ addr sz v) = ( Some (addr, sz, v, B0))\<close> 
  for  addr  :: " nat " 
  and  sz  :: " nat " 
  and  v  :: "(memory_byte)list "
|\<open> reads_mem_val _ = ( None )\<close>


\<comment> \<open>\<open>val reads_mem_cap : forall 'regval 'cap. Capability 'cap =>
  event 'regval -> maybe (address * nat * 'cap)\<close>\<close>
definition reads_mem_cap  :: \<open> 'cap Capability_class \<Rightarrow> 'regval event \<Rightarrow>(nat*nat*'cap)option \<close>  where 
     \<open> reads_mem_cap dict_Capabilities_Capability_cap e = (
  Option.bind (reads_mem_val e) ( (\<lambda>x .  
  (case  x of
      (addr, sz, v, t) =>
  Option.bind
    ((cap_of_mem_bytes_method   dict_Capabilities_Capability_cap) v t)
    ((\<lambda> c . 
     if(is_tagged_method   dict_Capabilities_Capability_cap) c then
       Some (addr, sz, c) else None))
  ))))\<close> 
  for  dict_Capabilities_Capability_cap  :: " 'cap Capability_class " 
  and  e  :: " 'regval event "


\<comment> \<open>\<open>val writes_mem_val : forall 'regval. event 'regval -> maybe (address * nat * list memory_byte * bitU)\<close>\<close>
fun writes_mem_val  :: \<open> 'regval event \<Rightarrow>(nat*nat*(memory_byte)list*bitU)option \<close>  where 
     \<open> writes_mem_val (E_write_memt _ addr sz v t _) = ( Some (addr, sz, v, t))\<close> 
  for  addr  :: " nat " 
  and  sz  :: " nat " 
  and  t  :: " bitU " 
  and  v  :: "(memory_byte)list "
|\<open> writes_mem_val (E_write_mem _ addr sz v _) = ( Some (addr, sz, v, B0))\<close> 
  for  addr  :: " nat " 
  and  sz  :: " nat " 
  and  v  :: "(memory_byte)list "
|\<open> writes_mem_val _ = ( None )\<close>


\<comment> \<open>\<open>val writes_mem_cap : forall 'regval 'cap. Capability 'cap =>
  event 'regval -> maybe (address * nat * 'cap)\<close>\<close>
definition writes_mem_cap  :: \<open> 'cap Capability_class \<Rightarrow> 'regval event \<Rightarrow>(nat*nat*'cap)option \<close>  where 
     \<open> writes_mem_cap dict_Capabilities_Capability_cap e = (
  Option.bind (writes_mem_val e) ( (\<lambda>x .  
  (case  x of
      (addr, sz, v, t) =>
  Option.bind
    ((cap_of_mem_bytes_method   dict_Capabilities_Capability_cap) v t)
    ((\<lambda> c . 
     if(is_tagged_method   dict_Capabilities_Capability_cap) c then
       Some (addr, sz, c) else None))
  ))))\<close> 
  for  dict_Capabilities_Capability_cap  :: " 'cap Capability_class " 
  and  e  :: " 'regval event "

end
