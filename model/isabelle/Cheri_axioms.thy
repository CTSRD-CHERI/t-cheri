chapter \<open>Generated by Lem from \<open>cheri_axioms.lem\<close>.\<close>

theory "Cheri_axioms" 

imports
  Main
  "LEM.Lem_pervasives_extra"
  "Sail.Sail2_values"
  "Sail.Sail2_prompt_monad"
  "Sail.Sail2_operators"
  "Capabilities"

begin 

\<comment> \<open>\<open>open import Pervasives_extra\<close>\<close>
\<comment> \<open>\<open>open import Sail2_values\<close>\<close>
\<comment> \<open>\<open>open import Sail2_prompt_monad\<close>\<close>
\<comment> \<open>\<open>open import Sail2_operators\<close>\<close>
\<comment> \<open>\<open>open import Capabilities\<close>\<close>

\<comment> \<open>\<open> ISA characterisation for the abstract CHERI model \<close>\<close>

\<comment> \<open>\<open> Memory access types
   TODO: Maybe add a read_kind for instruction fetches, so that we can
   distinguish loads from fetches in events and don't need to carry around the
   is_fetch parameter below.  Similarly, a {read,write}_kind for translation
   table accesses would be useful. \<close>\<close>
datatype acctype = Load | Store | Fetch | PTW \<comment> \<open>\<open> page table walk \<close>\<close>

record( 'cap, 'regval, 'instr, 'e) isa =
  
 instr_sem ::" 'instr \<Rightarrow> ('regval, unit, 'e) monad " 

     instr_fetch ::" ('regval, 'instr, 'e) monad " 

     tag_granule ::" nat " 

     PCC ::" register_name set " 

     KCC ::" register_name set " 

     IDC ::" register_name set " 

     caps_of_regval ::" 'regval \<Rightarrow> 'cap set " 

     uses_mem_caps ::" 'instr \<Rightarrow> 'regval trace \<Rightarrow> bool " 

     invokes_indirect_caps ::" 'instr \<Rightarrow> 'regval trace \<Rightarrow> 'cap set " 

     invokes_caps ::" 'instr \<Rightarrow> 'regval trace \<Rightarrow> 'cap set " 

     instr_raises_ex ::" 'instr \<Rightarrow> 'regval trace \<Rightarrow> bool " 

     fetch_raises_ex ::" 'regval trace \<Rightarrow> bool " 

     exception_targets ::" 'regval set \<Rightarrow> 'cap set " 

     read_privileged_regs ::" register_name set " 

     write_privileged_regs ::" register_name set " 

     read_exception_regs ::" register_name set " 

     write_exception_regs ::" register_name set " 

     is_translation_event ::" 'regval event \<Rightarrow> bool " 

     translate_address ::" address0 \<Rightarrow> acctype \<Rightarrow> 'regval trace \<Rightarrow>  address0 option " 


\<comment> \<open>\<open> Helper functions \<close>\<close>

definition writes_mem_val_at_idx  :: \<open> nat \<Rightarrow>('a event)list \<Rightarrow>(address0*nat*(memory_byte)list*bitU)option \<close>  where 
     \<open> writes_mem_val_at_idx i t = ( Option.bind (index t i) writes_mem_val )\<close> 
  for  i  :: " nat " 
  and  t  :: "('a event)list "

definition writes_mem_cap_at_idx  :: \<open> 'a Capability_class \<Rightarrow> nat \<Rightarrow>('b event)list \<Rightarrow>(address0*nat*'a)option \<close>  where 
     \<open> writes_mem_cap_at_idx dict_Capabilities_Capability_a i t = ( Option.bind (index t i) 
  (writes_mem_cap dict_Capabilities_Capability_a) )\<close> 
  for  dict_Capabilities_Capability_a  :: " 'a Capability_class " 
  and  i  :: " nat " 
  and  t  :: "('b event)list "

definition writes_to_reg_at_idx  :: \<open> nat \<Rightarrow>('a event)list \<Rightarrow>(string)option \<close>  where 
     \<open> writes_to_reg_at_idx i t = ( Option.bind (index t i) writes_to_reg )\<close> 
  for  i  :: " nat " 
  and  t  :: "('a event)list "

definition writes_reg_caps_at_idx  :: \<open> 'd Capability_class \<Rightarrow>('d,'c,'b,'a)isa \<Rightarrow> nat \<Rightarrow>('c event)list \<Rightarrow> 'd set \<close>  where 
     \<open> writes_reg_caps_at_idx dict_Capabilities_Capability_d ISA i t = ( case_option {} (writes_reg_caps 
  dict_Capabilities_Capability_d(caps_of_regval   ISA)) (index t i))\<close> 
  for  dict_Capabilities_Capability_d  :: " 'd Capability_class " 
  and  ISA  :: "('d,'c,'b,'a)isa " 
  and  i  :: " nat " 
  and  t  :: "('c event)list "

definition reads_mem_val_at_idx  :: \<open> nat \<Rightarrow>('a event)list \<Rightarrow>(address0*nat*(memory_byte)list*bitU)option \<close>  where 
     \<open> reads_mem_val_at_idx i t = ( Option.bind (index t i) reads_mem_val )\<close> 
  for  i  :: " nat " 
  and  t  :: "('a event)list "

definition reads_mem_cap_at_idx  :: \<open> 'a Capability_class \<Rightarrow> nat \<Rightarrow>('b event)list \<Rightarrow>(address0*nat*'a)option \<close>  where 
     \<open> reads_mem_cap_at_idx dict_Capabilities_Capability_a i t = ( Option.bind (index t i) 
  (reads_mem_cap dict_Capabilities_Capability_a) )\<close> 
  for  dict_Capabilities_Capability_a  :: " 'a Capability_class " 
  and  i  :: " nat " 
  and  t  :: "('b event)list "

definition reads_from_reg_at_idx  :: \<open> nat \<Rightarrow>('a event)list \<Rightarrow>(string)option \<close>  where 
     \<open> reads_from_reg_at_idx i t = ( Option.bind (index t i) reads_from_reg )\<close> 
  for  i  :: " nat " 
  and  t  :: "('a event)list "

definition reads_reg_caps_at_idx  :: \<open> 'd Capability_class \<Rightarrow>('d,'c,'b,'a)isa \<Rightarrow> nat \<Rightarrow>('c event)list \<Rightarrow> 'd set \<close>  where 
     \<open> reads_reg_caps_at_idx dict_Capabilities_Capability_d ISA i t = ( case_option {} (reads_reg_caps 
  dict_Capabilities_Capability_d(caps_of_regval   ISA)) (index t i))\<close> 
  for  dict_Capabilities_Capability_d  :: " 'd Capability_class " 
  and  ISA  :: "('d,'c,'b,'a)isa " 
  and  i  :: " nat " 
  and  t  :: "('c event)list "

definition translation_event_at_idx  :: \<open>('d,'c,'b,'a)isa \<Rightarrow> nat \<Rightarrow>('c event)list \<Rightarrow> bool \<close>  where 
     \<open> translation_event_at_idx ISA i t = ( (case  (index t i) of
    Some e =>(is_translation_event   ISA) e
  | None => False
))\<close> 
  for  ISA  :: "('d,'c,'b,'a)isa " 
  and  i  :: " nat " 
  and  t  :: "('c event)list "

definition exception_targets_at_idx  :: \<open>('d,'a,'c,'b)isa \<Rightarrow> nat \<Rightarrow>('a event)list \<Rightarrow> 'd set \<close>  where 
     \<open> exception_targets_at_idx ISA i t = ((exception_targets   ISA) {v' .( \<exists> r'.  \<exists> j.  (j < i) \<and> ((index t j = Some (E_read_reg r' v')) \<and> (r' \<in>(KCC   ISA))))})\<close> 
  for  ISA  :: "('d,'a,'c,'b)isa " 
  and  i  :: " nat " 
  and  t  :: "('a event)list "


\<comment> \<open>\<open>val address_tag_aligned : forall 'cap 'regval 'instr 'e.
  isa 'cap 'regval 'instr 'e -> address -> bool\<close>\<close>
definition address_tag_aligned  :: \<open>('cap,'regval,'instr,'e)isa \<Rightarrow> nat \<Rightarrow> bool \<close>  where 
     \<open> address_tag_aligned ISA addr = ( ((addr mod(tag_granule   ISA)) =( 0 :: nat)))\<close> 
  for  ISA  :: "('cap,'regval,'instr,'e)isa " 
  and  addr  :: " nat "


\<comment> \<open>\<open>val cap_reg_written_before_idx : forall 'cap 'regval 'instr 'e. Capability 'cap, Eq 'cap, SetType 'cap =>
  isa 'cap 'regval 'instr 'e -> nat -> register_name -> trace 'regval -> bool\<close>\<close>
definition cap_reg_written_before_idx  :: \<open> 'cap Capability_class \<Rightarrow>('cap,'regval,'instr,'e)isa \<Rightarrow> nat \<Rightarrow> string \<Rightarrow>('regval event)list \<Rightarrow> bool \<close>  where 
     \<open> cap_reg_written_before_idx dict_Capabilities_Capability_cap ISA i r t = ( ((\<exists> j.  (j < i) \<and> ((writes_to_reg_at_idx j t = Some r) \<and> \<not> (writes_reg_caps_at_idx 
  dict_Capabilities_Capability_cap ISA j t = {})))))\<close> 
  for  dict_Capabilities_Capability_cap  :: " 'cap Capability_class " 
  and  ISA  :: "('cap,'regval,'instr,'e)isa " 
  and  i  :: " nat " 
  and  r  :: " string " 
  and  t  :: "('regval event)list "


\<comment> \<open>\<open>val system_access_permitted_before_idx : forall 'cap 'regval 'instr 'e. Capability 'cap, SetType 'cap, Eq 'cap =>
  isa 'cap 'regval 'instr 'e -> nat -> trace 'regval -> bool\<close>\<close>
definition system_access_permitted_before_idx  :: \<open> 'cap Capability_class \<Rightarrow>('cap,'regval,'instr,'e)isa \<Rightarrow> nat \<Rightarrow>('regval event)list \<Rightarrow> bool \<close>  where 
     \<open> system_access_permitted_before_idx dict_Capabilities_Capability_cap ISA i t = (
  ((\<exists> j. \<exists> r. \<exists> c. 
     (j < i) \<and>
     ((reads_from_reg_at_idx j t = Some r) \<and>
     (\<not> (cap_reg_written_before_idx 
  dict_Capabilities_Capability_cap ISA j r t) \<and>
     ((c \<in> (reads_reg_caps_at_idx 
  dict_Capabilities_Capability_cap ISA j t)) \<and>
     ((r \<in>(PCC   ISA)) \<and> ((r \<notin>(read_privileged_regs   ISA)) \<and>
     ((is_tagged_method   dict_Capabilities_Capability_cap) c \<and> (\<not> ((is_sealed_method   dict_Capabilities_Capability_cap) c) \<and> (permits_system_access_method   dict_Capabilities_Capability_cap) c))))))))))\<close> 
  for  dict_Capabilities_Capability_cap  :: " 'cap Capability_class " 
  and  ISA  :: "('cap,'regval,'instr,'e)isa " 
  and  i  :: " nat " 
  and  t  :: "('regval event)list "


\<comment> \<open>\<open>val permits_cap_load : forall 'cap. Capability 'cap => 'cap -> address -> nat -> bool\<close>\<close>
definition permits_cap_load  :: \<open> 'cap Capability_class \<Rightarrow> 'cap \<Rightarrow> nat \<Rightarrow> nat \<Rightarrow> bool \<close>  where 
     \<open> permits_cap_load dict_Capabilities_Capability_cap c vaddr sz = (
  ((is_tagged_method   dict_Capabilities_Capability_cap) c \<and> (\<not> ((is_sealed_method   dict_Capabilities_Capability_cap) c) \<and>
   ((List.set (address_range vaddr sz) \<subseteq> (get_mem_region 
  dict_Capabilities_Capability_cap c)) \<and> (permits_load_cap_method   dict_Capabilities_Capability_cap) c))))\<close> 
  for  dict_Capabilities_Capability_cap  :: " 'cap Capability_class " 
  and  c  :: " 'cap " 
  and  vaddr  :: " nat " 
  and  sz  :: " nat "


\<comment> \<open>\<open> Characterisation of available capabilities at given point in a trace \<close>\<close>

\<comment> \<open>\<open>val available_mem_caps : forall 'cap 'regval 'instr 'e. Capability 'cap, Eq 'cap, SetType 'cap =>
  isa 'cap 'regval 'instr 'e -> nat -> trace 'regval -> set 'cap\<close>\<close>
fun  available_mem_caps  :: \<open> 'cap Capability_class \<Rightarrow>('cap,'regval,'instr,'e)isa \<Rightarrow> nat \<Rightarrow>('regval event)list \<Rightarrow> 'cap set \<close>  where 
     \<open> available_mem_caps dict_Capabilities_Capability_cap ISA 0 t = ( {} )\<close> 
  for  dict_Capabilities_Capability_cap  :: " 'cap Capability_class " 
  and  ISA  :: "('cap,'regval,'instr,'e)isa " 
  and  t  :: "('regval event)list "
|\<open> available_mem_caps dict_Capabilities_Capability_cap ISA ((Suc i)) t = ( 
  (let caps_of = ((\<lambda> e . 
                  \<comment> \<open>\<open> Collect capabilities read from memory \<close>\<close>
                  (case  reads_mem_cap dict_Capabilities_Capability_cap e of
                        Some (_, _, c) =>
                  \<comment> \<open>\<open> ... but ignore memory loads that happen as part of address translation \<close>\<close>
                  if(is_translation_event   ISA) e then {} else {c}
                    | None => {}
                  ))) in
  (let new_caps = (case_option {} caps_of (index t i)) in
  (available_mem_caps dict_Capabilities_Capability_cap ISA i t) \<union>
    new_caps)) )\<close> 
  for  dict_Capabilities_Capability_cap  :: " 'cap Capability_class " 
  and  ISA  :: "('cap,'regval,'instr,'e)isa " 
  and  i  :: " nat " 
  and  t  :: "('regval event)list "


\<comment> \<open>\<open>val available_reg_caps : forall 'cap 'regval 'instr 'e. Capability 'cap, Eq 'cap, SetType 'cap =>
  isa 'cap 'regval 'instr 'e -> nat -> trace 'regval -> set 'cap\<close>\<close>
fun  available_reg_caps  :: \<open> 'cap Capability_class \<Rightarrow>('cap,'regval,'instr,'e)isa \<Rightarrow> nat \<Rightarrow>('regval event)list \<Rightarrow> 'cap set \<close>  where 
     \<open> available_reg_caps dict_Capabilities_Capability_cap ISA 0 t = ( {} )\<close> 
  for  dict_Capabilities_Capability_cap  :: " 'cap Capability_class " 
  and  ISA  :: "('cap,'regval,'instr,'e)isa " 
  and  t  :: "('regval event)list "
|\<open> available_reg_caps dict_Capabilities_Capability_cap ISA ((Suc i)) t = ( 
  (let caps_of = ((\<lambda> e . 
                  ((case  reads_from_reg e of
                         Some r =>
                   \<comment> \<open>\<open> Collect capabilities read from accessible registers (if PCC or IDC have been written to,
                we don't allow the use of capabilities read back from them, as those might come from a
                non-monotonic capability invocation) \<close>\<close>
                   if ((((r \<in> (PCC   ISA)) \<or> (r \<in> (IDC   ISA)))
                          \<longrightarrow>
                          \<not>
                            (cap_reg_written_before_idx
                               dict_Capabilities_Capability_cap ISA i 
                             r t)) \<and>
                         (system_access_permitted_before_idx
                            dict_Capabilities_Capability_cap ISA i t \<or>
                            \<not> (r \<in> (read_privileged_regs   ISA))))
                   then
                     reads_reg_caps dict_Capabilities_Capability_cap
                       (caps_of_regval   ISA) e else {}
                     | None => {}
                   )))) in
  (let new_caps = (case_option {} caps_of (index t i)) in
  (available_reg_caps dict_Capabilities_Capability_cap ISA i t) \<union>
    new_caps)) )\<close> 
  for  dict_Capabilities_Capability_cap  :: " 'cap Capability_class " 
  and  ISA  :: "('cap,'regval,'instr,'e)isa " 
  and  i  :: " nat " 
  and  t  :: "('regval event)list "


\<comment> \<open>\<open> Collect capabilities available from register reads or, possibly, memory
   loads (we disallow use of capabilities loaded from memory in case of
   instructions that perform indirect sentry invocations \<close>\<close>
\<comment> \<open>\<open>val available_caps : forall 'cap 'regval 'instr 'e. Capability 'cap, Eq 'cap, SetType 'cap =>
  isa 'cap 'regval 'instr 'e -> bool -> nat -> trace 'regval -> set 'cap\<close>\<close>
definition available_caps  :: \<open> 'cap Capability_class \<Rightarrow>('cap,'regval,'instr,'e)isa \<Rightarrow> bool \<Rightarrow> nat \<Rightarrow>('regval event)list \<Rightarrow> 'cap set \<close>  where 
     \<open> available_caps dict_Capabilities_Capability_cap ISA use_mem_caps i t = (
  (available_reg_caps 
  dict_Capabilities_Capability_cap ISA i t) \<union> (if use_mem_caps then available_mem_caps 
  dict_Capabilities_Capability_cap ISA i t else {}))\<close> 
  for  dict_Capabilities_Capability_cap  :: " 'cap Capability_class " 
  and  ISA  :: "('cap,'regval,'instr,'e)isa " 
  and  use_mem_caps  :: " bool " 
  and  i  :: " nat " 
  and  t  :: "('regval event)list "


\<comment> \<open>\<open> Properties we require for CHERI ISAs \<close>\<close>

\<comment> \<open>\<open>val read_reg_axiom : forall 'cap 'regval 'instr 'e. Capability 'cap, SetType 'cap, Eq 'cap, Eq 'regval =>
  isa 'cap 'regval 'instr 'e -> bool -> trace 'regval -> bool\<close>\<close>
definition read_reg_axiom  :: \<open> 'cap Capability_class \<Rightarrow>('cap,'regval,'instr,'e)isa \<Rightarrow> bool \<Rightarrow>('regval event)list \<Rightarrow> bool \<close>  where 
     \<open> read_reg_axiom dict_Capabilities_Capability_cap ISA has_ex t = (
  ((\<forall> i. \<forall> r. \<forall> v. 
     ((index t i = Some (E_read_reg r v)) \<and> (r \<in>(read_privileged_regs   ISA)))
     \<longrightarrow>
     \<comment> \<open>\<open> Check system access permission before reading privileged registers
        (allowing read_exception_regs in the exception case) \<close>\<close>
     (system_access_permitted_before_idx 
  dict_Capabilities_Capability_cap ISA i t \<or>
      (has_ex \<and> (r \<in>(read_exception_regs   ISA)))))))\<close> 
  for  dict_Capabilities_Capability_cap  :: " 'cap Capability_class " 
  and  ISA  :: "('cap,'regval,'instr,'e)isa " 
  and  has_ex  :: " bool " 
  and  t  :: "('regval event)list "


\<comment> \<open>\<open>val write_reg_axiom : forall 'cap 'regval 'instr 'e. Capability 'cap, SetType 'cap, Eq 'cap, Eq 'regval =>
  isa 'cap 'regval 'instr 'e -> bool -> trace 'regval -> bool\<close>\<close>
definition write_reg_axiom  :: \<open> 'cap Capability_class \<Rightarrow>('cap,'regval,'instr,'e)isa \<Rightarrow> bool \<Rightarrow>('regval event)list \<Rightarrow> bool \<close>  where 
     \<open> write_reg_axiom dict_Capabilities_Capability_cap ISA has_ex t = (
  ((\<forall> i. \<forall> r. \<forall> v. 
     ((index t i = Some (E_write_reg r v)) \<and> (r \<in>(write_privileged_regs   ISA)))
     \<longrightarrow>
     (system_access_permitted_before_idx 
  dict_Capabilities_Capability_cap ISA i t \<or>
      (has_ex \<and> (r \<in>(write_exception_regs   ISA)))))))\<close> 
  for  dict_Capabilities_Capability_cap  :: " 'cap Capability_class " 
  and  ISA  :: "('cap,'regval,'instr,'e)isa " 
  and  has_ex  :: " bool " 
  and  t  :: "('regval event)list "


\<comment> \<open>\<open>val store_cap_mem_axiom : forall 'cap 'regval 'instr 'e. Capability 'cap, SetType 'cap, Eq 'cap =>
  isa 'cap 'regval 'instr 'e -> set 'cap -> bool -> set 'cap -> trace 'regval -> bool\<close>\<close>
definition store_cap_mem_axiom  :: \<open> 'cap Capability_class \<Rightarrow>('cap,'regval,'instr,'e)isa \<Rightarrow> 'cap set \<Rightarrow> bool \<Rightarrow> 'cap set \<Rightarrow>('regval event)list \<Rightarrow> bool \<close>  where 
     \<open> store_cap_mem_axiom dict_Capabilities_Capability_cap ISA initial_caps use_mem_caps invoked_indirect_caps t = (
  ((\<forall> i. \<forall> c. \<forall> addr. \<forall> sz. 
     (writes_mem_cap_at_idx 
  dict_Capabilities_Capability_cap i t = Some (addr, sz, c))
     \<longrightarrow>
     \<comment> \<open>\<open> Only store monotonically derivable capabilities to memory \<close>\<close>
     (cap_derivable dict_Capabilities_Capability_cap (initial_caps \<union> available_caps 
  dict_Capabilities_Capability_cap ISA ((invoked_indirect_caps = {}) \<and> use_mem_caps) i t) c))))\<close> 
  for  dict_Capabilities_Capability_cap  :: " 'cap Capability_class " 
  and  ISA  :: "('cap,'regval,'instr,'e)isa " 
  and  initial_caps  :: " 'cap set " 
  and  use_mem_caps  :: " bool " 
  and  invoked_indirect_caps  :: " 'cap set " 
  and  t  :: "('regval event)list "


\<comment> \<open>\<open>val store_cap_reg_axiom : forall 'cap 'regval 'instr 'e. Capability 'cap, SetType 'cap, SetType 'regval, Eq 'cap, Eq 'regval =>
  isa 'cap 'regval 'instr 'e -> bool -> set 'cap -> bool -> set 'cap -> set 'cap -> trace 'regval -> bool\<close>\<close>
definition store_cap_reg_axiom  :: \<open> 'cap Capability_class \<Rightarrow>('cap,'regval,'instr,'e)isa \<Rightarrow> bool \<Rightarrow> 'cap set \<Rightarrow> bool \<Rightarrow> 'cap set \<Rightarrow> 'cap set \<Rightarrow>('regval event)list \<Rightarrow> bool \<close>  where 
     \<open> store_cap_reg_axiom dict_Capabilities_Capability_cap ISA has_ex initial_caps use_mem_caps invoked_caps invoked_indirect_caps t = (
  ((\<forall> i. \<forall> c. \<forall> r. 
     ((writes_to_reg_at_idx i t = Some r) \<and> (c \<in> (writes_reg_caps_at_idx 
  dict_Capabilities_Capability_cap ISA i t)))
     \<longrightarrow>
     \<comment> \<open>\<open> Only store monotonically derivable capabilities to registers \<close>\<close>
     (cap_derivable dict_Capabilities_Capability_cap (initial_caps \<union> available_caps 
  dict_Capabilities_Capability_cap ISA ((invoked_indirect_caps = {}) \<and> use_mem_caps) i t) c \<or>
     (
     \<comment> \<open>\<open> ... or perform one of the following non-monotonic register writes: \<close>\<close>
     \<comment> \<open>\<open> Exception \<close>\<close>(has_ex \<and> ((c \<in> exception_targets_at_idx ISA i t) \<and> (r \<in>(PCC   ISA)))) \<or>
     (
     \<comment> \<open>\<open> Capability pair invocation \<close>\<close>((\<exists> cc. \<exists> cd0. 
        (c \<in> invoked_caps) \<and>
        (cap_derivable 
  dict_Capabilities_Capability_cap (initial_caps \<union> available_caps 
  dict_Capabilities_Capability_cap ISA ((invoked_indirect_caps = {}) \<and> use_mem_caps) i t) cc \<and>
        (cap_derivable 
  dict_Capabilities_Capability_cap (initial_caps \<union> available_caps 
  dict_Capabilities_Capability_cap ISA ((invoked_indirect_caps = {}) \<and> use_mem_caps) i t) cd0 \<and>
        (invokable dict_Capabilities_Capability_cap cc cd0 \<and>
        ((leq_cap dict_Capabilities_Capability_cap c ((unseal_method   dict_Capabilities_Capability_cap) cc) \<and> (r \<in>(PCC   ISA))) \<or>
         (leq_cap dict_Capabilities_Capability_cap c ((unseal_method   dict_Capabilities_Capability_cap) cd0) \<and> (r \<in>(IDC   ISA))))))))) \<or>
     (
     \<comment> \<open>\<open> Direct sentry invocation \<close>\<close>((\<exists> cs. 
        (c \<in> invoked_caps) \<and>
        (cap_derivable 
  dict_Capabilities_Capability_cap (initial_caps \<union> available_caps 
  dict_Capabilities_Capability_cap ISA ((invoked_indirect_caps = {}) \<and> use_mem_caps) i t) cs \<and>
        ((is_sentry_method   dict_Capabilities_Capability_cap) cs \<and>
        ((is_sealed_method   dict_Capabilities_Capability_cap) cs \<and>
        (leq_cap dict_Capabilities_Capability_cap c ((unseal_method   dict_Capabilities_Capability_cap) cs) \<and>
        (r \<in>(PCC   ISA)))))))) \<or>
     (
     \<comment> \<open>\<open> Indirect sentry invocation (writing the unsealed sentry to IDC) \<close>\<close>((\<exists> cs. 
        (c \<in> invoked_indirect_caps) \<and>
        (cap_derivable 
  dict_Capabilities_Capability_cap (initial_caps \<union> available_reg_caps 
  dict_Capabilities_Capability_cap ISA i t) cs \<and>
        ((is_indirect_sentry_method   dict_Capabilities_Capability_cap) cs \<and>
        ((is_sealed_method   dict_Capabilities_Capability_cap) cs \<and>
        (leq_cap dict_Capabilities_Capability_cap c ((unseal_method   dict_Capabilities_Capability_cap) cs) \<and>
        (r \<in>(IDC   ISA)))))))) \<or>
     \<comment> \<open>\<open> Indirect capability (pair) invocation (writing the loaded capability/capabilities to PCC/IDC) \<close>\<close>
     ((\<exists> c'. 
        (c \<in> invoked_caps) \<and> (\<not> (invoked_indirect_caps = {}) \<and> (use_mem_caps \<and>
        (cap_derivable 
  dict_Capabilities_Capability_cap (initial_caps \<union> available_mem_caps 
  dict_Capabilities_Capability_cap ISA i t) c' \<and>
        ((leq_cap dict_Capabilities_Capability_cap c ((unseal_method   dict_Capabilities_Capability_cap) c') \<and> ((is_sealed_method   dict_Capabilities_Capability_cap) c' \<and> ((is_sentry_method   dict_Capabilities_Capability_cap) c' \<and> (r \<in>(PCC   ISA))))) \<or>
         (leq_cap dict_Capabilities_Capability_cap c c' \<and> (r \<in> ((PCC   ISA) \<union>(IDC   ISA))))))))))))))))))\<close> 
  for  dict_Capabilities_Capability_cap  :: " 'cap Capability_class " 
  and  ISA  :: "('cap,'regval,'instr,'e)isa " 
  and  has_ex  :: " bool " 
  and  initial_caps  :: " 'cap set " 
  and  use_mem_caps  :: " bool " 
  and  invoked_caps  :: " 'cap set " 
  and  invoked_indirect_caps  :: " 'cap set " 
  and  t  :: "('regval event)list "


\<comment> \<open>\<open> TODO: The above allows writing invoked capabilities to IDC without also
   setting PCC;  add a requirement that capability invocation either writes
   only PCC or both PCC and IDC. \<close>\<close>

\<comment> \<open>\<open>val load_mem_axiom : forall 'cap 'regval 'instr 'e. Capability 'cap, SetType 'cap, Eq 'cap =>
  isa 'cap 'regval 'instr 'e -> bool -> set 'cap -> bool -> set 'cap -> trace 'regval -> bool\<close>\<close>
definition load_mem_axiom  :: \<open> 'cap Capability_class \<Rightarrow>('cap,'regval,'instr,'e)isa \<Rightarrow> bool \<Rightarrow> 'cap set \<Rightarrow> bool \<Rightarrow> 'cap set \<Rightarrow>('regval event)list \<Rightarrow> bool \<close>  where 
     \<open> load_mem_axiom dict_Capabilities_Capability_cap ISA is_fetch initial_caps use_mem_caps invoked_indirect_caps t = (
  ((\<forall> i. \<forall> paddr. \<forall> sz. \<forall> v. \<forall> tag. 
     ((reads_mem_val_at_idx i t = Some (paddr, sz, v, tag)) \<and>
      \<not> (translation_event_at_idx ISA i t))
     \<longrightarrow>
     \<comment> \<open>\<open> Only perform memory loads (outside address translation) with a suitable authorising capability \<close>\<close>
     ((\<exists> c'. \<exists> vaddr. 
        cap_derivable 
  dict_Capabilities_Capability_cap (initial_caps \<union> available_caps 
  dict_Capabilities_Capability_cap ISA ((invoked_indirect_caps = {}) \<and> use_mem_caps) i t) c' \<and> (
  (is_tagged_method   dict_Capabilities_Capability_cap) c' \<and>
        (((is_sealed_method   dict_Capabilities_Capability_cap) c' \<longrightarrow> (
  (is_indirect_sentry_method   dict_Capabilities_Capability_cap) c' \<and> ((unseal_method   dict_Capabilities_Capability_cap) c' \<in> invoked_indirect_caps))) \<and>
        (((translate_address   ISA) vaddr (if is_fetch then Fetch else Load) (List.take i t) = Some paddr) \<and>
        ((List.set (address_range vaddr sz) \<subseteq> (get_mem_region 
  dict_Capabilities_Capability_cap c')) \<and>
        ((if is_fetch then 
  (permits_execute_method   dict_Capabilities_Capability_cap) c' else (permits_load_method   dict_Capabilities_Capability_cap) c') \<and>
        ((is_fetch \<longrightarrow> (tag = B0)) \<and>
        (((tag \<noteq> B0) \<and> use_mem_caps) \<longrightarrow> (
  (permits_load_cap_method   dict_Capabilities_Capability_cap) c' \<and> ((sz =(tag_granule   ISA)) \<and> address_tag_aligned ISA paddr))))))))))))))\<close> 
  for  dict_Capabilities_Capability_cap  :: " 'cap Capability_class " 
  and  ISA  :: "('cap,'regval,'instr,'e)isa " 
  and  is_fetch  :: " bool " 
  and  initial_caps  :: " 'cap set " 
  and  use_mem_caps  :: " bool " 
  and  invoked_indirect_caps  :: " 'cap set " 
  and  t  :: "('regval event)list "


\<comment> \<open>\<open>val mem_val_is_cap : forall 'cap 'regval 'instr 'e. Capability 'cap, SetType 'cap, Eq 'cap =>
  isa 'cap 'regval 'instr 'e -> list memory_byte -> bitU -> bool\<close>\<close>
definition mem_val_is_cap  :: \<open> 'cap Capability_class \<Rightarrow>('cap,'regval,'instr,'e)isa \<Rightarrow>(memory_byte)list \<Rightarrow> bitU \<Rightarrow> bool \<close>  where 
     \<open> mem_val_is_cap dict_Capabilities_Capability_cap _ v t = ( ((\<exists> c. 
  (cap_of_mem_bytes_method   dict_Capabilities_Capability_cap) v t = Some (c :: 'cap))))\<close> 
  for  dict_Capabilities_Capability_cap  :: " 'cap Capability_class " 
  and  v  :: "(memory_byte)list " 
  and  t  :: " bitU "


\<comment> \<open>\<open>val mem_val_is_local_cap : forall 'cap 'regval 'instr 'e. Capability 'cap, SetType 'cap, Eq 'cap =>
  isa 'cap 'regval 'instr 'e -> list memory_byte -> bitU -> bool\<close>\<close>
definition mem_val_is_local_cap  :: \<open> 'cap Capability_class \<Rightarrow>('cap,'regval,'instr,'e)isa \<Rightarrow>(memory_byte)list \<Rightarrow> bitU \<Rightarrow> bool \<close>  where 
     \<open> mem_val_is_local_cap dict_Capabilities_Capability_cap _ v t = ( ((\<exists> c.  (
  (cap_of_mem_bytes_method   dict_Capabilities_Capability_cap) v t = Some (c :: 'cap)) \<and> \<not> (
  (is_global_method   dict_Capabilities_Capability_cap) c))))\<close> 
  for  dict_Capabilities_Capability_cap  :: " 'cap Capability_class " 
  and  v  :: "(memory_byte)list " 
  and  t  :: " bitU "


\<comment> \<open>\<open>val store_tag_axiom : forall 'cap 'regval 'instr 'e. Capability 'cap, SetType 'cap, Eq 'cap =>
  isa 'cap 'regval 'instr 'e -> trace 'regval -> bool\<close>\<close>
definition store_tag_axiom  :: \<open> 'cap Capability_class \<Rightarrow>('cap,'regval,'instr,'e)isa \<Rightarrow>('regval event)list \<Rightarrow> bool \<close>  where 
     \<open> store_tag_axiom dict_Capabilities_Capability_cap ISA t = (
  ((\<forall> i. \<forall> paddr. \<forall> sz. \<forall> v. \<forall> tag. 
     (writes_mem_val_at_idx i t = Some (paddr, sz, v, tag))
     \<longrightarrow>
     \<comment> \<open>\<open> Only store tagged memory values if they are capability-sized and aligned \<close>\<close>
     ((List.length v = sz) \<and>
      (((tag = B0) \<or> (tag = B1)) \<and>
      ((tag = B1) \<longrightarrow> (address_tag_aligned ISA paddr \<and> (sz =(tag_granule   ISA)))))))))\<close> 
  for  dict_Capabilities_Capability_cap  :: " 'cap Capability_class " 
  and  ISA  :: "('cap,'regval,'instr,'e)isa " 
  and  t  :: "('regval event)list "


\<comment> \<open>\<open>val store_mem_axiom : forall 'cap 'regval 'instr 'e. Capability 'cap, SetType 'cap, Eq 'cap =>
  isa 'cap 'regval 'instr 'e -> set 'cap -> bool -> set 'cap -> trace 'regval -> bool\<close>\<close>
definition store_mem_axiom  :: \<open> 'cap Capability_class \<Rightarrow>('cap,'regval,'instr,'e)isa \<Rightarrow> 'cap set \<Rightarrow> bool \<Rightarrow> 'cap set \<Rightarrow>('regval event)list \<Rightarrow> bool \<close>  where 
     \<open> store_mem_axiom dict_Capabilities_Capability_cap ISA initial_caps use_mem_caps invoked_indirect_caps t = (
  ((\<forall> i. \<forall> paddr. \<forall> sz. \<forall> v. \<forall> tag. 
     ((writes_mem_val_at_idx i t = Some (paddr, sz, v, tag)) \<and>
      \<not> (translation_event_at_idx ISA i t))
     \<longrightarrow>
     \<comment> \<open>\<open> Only perform memory stores (outside address translation) with a suitable authorising capability \<close>\<close>
     ((\<exists> c'. \<exists> vaddr. 
        cap_derivable 
  dict_Capabilities_Capability_cap (initial_caps \<union> available_caps 
  dict_Capabilities_Capability_cap ISA ((invoked_indirect_caps = {}) \<and> use_mem_caps) i t) c' \<and> (
  (is_tagged_method   dict_Capabilities_Capability_cap) c' \<and> (\<not> ((is_sealed_method   dict_Capabilities_Capability_cap) c') \<and>
        (((translate_address   ISA) vaddr Store (List.take i t) = Some paddr) \<and>
        ((List.set (address_range vaddr sz) \<subseteq> (get_mem_region 
  dict_Capabilities_Capability_cap c')) \<and>
        ((permits_store_method   dict_Capabilities_Capability_cap) c' \<and>
        (((mem_val_is_cap 
  dict_Capabilities_Capability_cap ISA v tag \<and> (tag = B1)) \<longrightarrow> 
  (permits_store_cap_method   dict_Capabilities_Capability_cap) c') \<and>
        ((mem_val_is_local_cap 
  dict_Capabilities_Capability_cap ISA v tag \<and> (tag = B1)) \<longrightarrow> 
  (permits_store_local_cap_method   dict_Capabilities_Capability_cap) c'))))))))))))\<close> 
  for  dict_Capabilities_Capability_cap  :: " 'cap Capability_class " 
  and  ISA  :: "('cap,'regval,'instr,'e)isa " 
  and  initial_caps  :: " 'cap set " 
  and  use_mem_caps  :: " bool " 
  and  invoked_indirect_caps  :: " 'cap set " 
  and  t  :: "('regval event)list "


\<comment> \<open>\<open>val cheri_axioms : forall 'cap 'regval 'instr 'e. Capability 'cap, SetType 'cap, SetType 'regval, Eq 'cap, Eq 'regval =>
  isa 'cap 'regval 'instr 'e -> bool -> bool -> set 'cap -> bool -> set 'cap -> set 'cap -> trace 'regval -> bool\<close>\<close>
definition cheri_axioms  :: \<open> 'cap Capability_class \<Rightarrow>('cap,'regval,'instr,'e)isa \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> 'cap set \<Rightarrow> bool \<Rightarrow> 'cap set \<Rightarrow> 'cap set \<Rightarrow>('regval event)list \<Rightarrow> bool \<close>  where 
     \<open> cheri_axioms dict_Capabilities_Capability_cap ISA is_fetch has_ex initial_caps use_mem_caps invoked_caps invoked_indirect_caps t = (
  store_cap_mem_axiom 
  dict_Capabilities_Capability_cap ISA initial_caps use_mem_caps invoked_indirect_caps t \<and>
  (store_cap_reg_axiom 
  dict_Capabilities_Capability_cap ISA has_ex initial_caps use_mem_caps invoked_caps invoked_indirect_caps t \<and>
  (read_reg_axiom dict_Capabilities_Capability_cap ISA has_ex t \<and>
  (write_reg_axiom dict_Capabilities_Capability_cap ISA has_ex t \<and>
  (load_mem_axiom dict_Capabilities_Capability_cap ISA is_fetch initial_caps use_mem_caps invoked_indirect_caps t \<and>
  (store_tag_axiom dict_Capabilities_Capability_cap ISA t \<and>
  store_mem_axiom dict_Capabilities_Capability_cap ISA initial_caps use_mem_caps invoked_indirect_caps t))))))\<close> 
  for  dict_Capabilities_Capability_cap  :: " 'cap Capability_class " 
  and  ISA  :: "('cap,'regval,'instr,'e)isa " 
  and  is_fetch  :: " bool " 
  and  has_ex  :: " bool " 
  and  initial_caps  :: " 'cap set " 
  and  use_mem_caps  :: " bool " 
  and  invoked_caps  :: " 'cap set " 
  and  invoked_indirect_caps  :: " 'cap set " 
  and  t  :: "('regval event)list "

end
